package gen

import (
	"bytes"
	"fmt"
	"go/format"
	"text/template"

	"sort"
	"strings"

	isir "github.com/reoring/goskema/internal/ir"
)

// File is a generated file content with package name and imports handled by template.
type File struct {
	Package string
	Types   []TypeStub
}

// TypeStub carries minimal data for code generation at this phase.
type TypeStub struct {
	Name string
}

// Template for object-only ParseFrom skeleton and validator stubs.
var fileTmpl = template.Must(template.New("file").Parse(`// Code generated by goskema compile; DO NOT EDIT.
// Generated by internal/gen

package {{.Package}}

import (
    "context"
    "fmt"
    "io"
    goskema "github.com/reoring/goskema"
)

{{range .Types}}
// Validate{{.Name}} is a stub for the compiled validator.
func Validate{{.Name}}(ctx context.Context, data any) ({{.Name}}, error) {
    var zero {{.Name}}
    return zero, fmt.Errorf("compiled validator for {{.Name}}: not implemented yet")
}

// ParseFrom{{.Name}} is a stub for the compiled streaming parser.
func ParseFrom{{.Name}}(ctx context.Context, src goskema.Source) ({{.Name}}, error) {
    // Example of applying runtime enforcement from generated code.
    _ = goskema.EnforceSource(src, goskema.ParseOpt{})
    var zero {{.Name}}
    return zero, fmt.Errorf("compiled ParseFrom{{.Name}}: not implemented yet")
}

// Validate{{.Name}}FromReader is a stub for the compiled io.Reader validator.
func Validate{{.Name}}FromReader(ctx context.Context, r io.Reader) ({{.Name}}, error) {
    var zero {{.Name}}
    return zero, fmt.Errorf("compiled Validate{{.Name}}FromReader: not implemented yet")
}
{{end}}
`))

// RenderFile renders the file template and formats the Go source.
func RenderFile(f File) ([]byte, error) {
	var buf bytes.Buffer
	if err := fileTmpl.Execute(&buf, f); err != nil {
		return nil, fmt.Errorf("render template: %w", err)
	}
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		// return unformatted with context for debugging
		return buf.Bytes(), nil
	}
	return formatted, nil
}

// ---- IR-aware rendering (object field skeleton) ----

// BoundField represents a JSON field bound to a Go struct field with a known kind.
type BoundField struct {
	JSON       string
	Go         string
	Kind       string // "string"|"bool"|"number"|"object"|"array"|""
	HasDefault bool
	DefaultLit string // best-effort Go literal for default when primitive
}

// TypeDef couples a type name with a simplified view for rendering.
type TypeDef struct {
	Name   string
	Fields []string // if non-empty, treated as object schema skeleton
	// Optional IR-projected hints for skeleton wiring. When empty/zero, sensible defaults apply.
	Required      []string          // required field JSON names
	UnknownPolicy int               // mirrors goskema.UnknownPolicy values
	UnknownTarget string            // JSON Pointer or field name placeholder (not yet used)
	Bindings      map[string]string // JSON name -> Go struct field name
	Kinds         map[string]string // JSON name -> schema kind ("string"|"bool"|"number"|"object"|"array")
	Defaults      map[string]any    // JSON name -> default value (wire shape) when available
	BoundFields   []BoundField      // materialized bindings for template convenience
}

var fileIRTmpl = template.Must(template.New("fileIR").Parse(`// Code generated by goskema compile; DO NOT EDIT.
// Generated by internal/gen

package {{.Package}}

import (
    "context"
    "fmt"
    "io"
    goskema "github.com/reoring/goskema"
)

{{range .Types}}
{{$tn := .Name}}
// Validate{{.Name}} is a stub for the compiled validator.
func Validate{{.Name}}(ctx context.Context, data any) ({{.Name}}, error) {
    var zero {{.Name}}
    return zero, fmt.Errorf("compiled validator for {{.Name}}: not implemented yet")
}

// ParseFrom{{.Name}} is a stub for the compiled streaming parser.
func ParseFrom{{.Name}}(ctx context.Context, src goskema.Source) ({{.Name}}, error) {
    // Parse options placeholder. Generators will populate fields as needed.
    var opt goskema.ParseOpt
    // Local issue collection; enforcement is applied only when needed.
    var issues goskema.Issues
    src = goskema.EnforceSourceIfNeeded(src, opt)
    // Wire fail-fast into context so downstream validators can honor it.
    ctx = goskema.WithFailFast(ctx, opt.FailFast)
    // expect begin-object
    tok, err := src.NextToken()
    if err != nil {
        return {{.Name}}{}, fmt.Errorf("parse error: %w", err)
    }
    if tok.Kind != goskema.TokenBeginObject {
        // invalid_type as Issues for uniformity
        var zero {{.Name}}
        iss := goskema.AppendIssues(nil, goskema.Issue{Code: goskema.CodeInvalidType, Path: "/", Message: "expected object"})
        return zero, iss
    }
    // field loop skeleton (known fields listed for future inline branches)
    {{if .Fields}}
    // known fields: {{range $i, $f := .Fields}}{{if $i}}, {{end}}"{{$f}}"{{end}}
    // seen map for required check at end
    seen := map[string]bool{ {{range .Fields}}"{{.}}": false, {{end}} }
    // unknown policy (default Strict until IR wiring populates it)
    unknownPolicy := goskema.UnknownPolicy({{.UnknownPolicy}})
    // presence collection is only for WithMeta variants; omit here for performance
    // output value
    var out {{.Name}}
    // helper to skip an entire value subtree
    skipValue := func(s goskema.Source) error {
        v, err := s.NextToken()
        if err != nil { return err }
        switch v.Kind {
        case goskema.TokenBeginObject:
            depth := 1
            for depth > 0 {
                t, err := s.NextToken()
                if err != nil { return err }
                switch t.Kind {
                case goskema.TokenBeginObject, goskema.TokenBeginArray:
                    depth++
                case goskema.TokenEndObject, goskema.TokenEndArray:
                    depth--
                }
            }
        case goskema.TokenBeginArray:
            depth := 1
            for depth > 0 {
                t, err := s.NextToken()
                if err != nil { return err }
                switch t.Kind {
                case goskema.TokenBeginObject, goskema.TokenBeginArray:
                    depth++
                case goskema.TokenEndObject, goskema.TokenEndArray:
                    depth--
                }
            }
        default:
            // primitives: nothing to do
        }
        return nil
    }
    for {
        t, err := src.NextToken()
        if err != nil {
            var zero {{.Name}}
            return zero, fmt.Errorf("parse error: %w", err)
        }
        if t.Kind == goskema.TokenEndObject {
            break
        }
        if t.Kind != goskema.TokenKey {
            var zero {{.Name}}
            return zero, goskema.Issues{goskema.Issue{Code: goskema.CodeParseError, Path: "/", Message: "unexpected token in object"}}
        }
        k := t.String
        // inline branches per known field name
        switch k {
        {{- if .BoundFields }}
        {{- range .BoundFields }}
        case "{{.JSON}}":
            seen["{{.JSON}}"] = true
            vt, err := src.NextToken()
            if err != nil { var zero {{$tn}}; return zero, fmt.Errorf("parse error: %w", err) }
            {{- if eq .Kind "string" }}
            if vt.Kind != goskema.TokenString {
                if vt.Kind == goskema.TokenBeginObject || vt.Kind == goskema.TokenBeginArray {
                    depth := 1
                    for depth > 0 {
                        t2, err := src.NextToken()
                        if err != nil { var zero {{$tn}}; return zero, fmt.Errorf("parse error: %w", err) }
                        switch t2.Kind {
                        case goskema.TokenBeginObject, goskema.TokenBeginArray:
                            depth++
                        case goskema.TokenEndObject, goskema.TokenEndArray:
                            depth--
                        }
                    }
                }
                issues = goskema.AppendIssues(issues, goskema.Issue{Code: goskema.CodeInvalidType, Path: "/{{.JSON}}", Message: "expected string"})
                if goskema.IsFailFast(ctx) { var zero {{$tn}}; return zero, issues }
                continue
            }
            out.{{.Go}} = vt.String
            {{- else if eq .Kind "bool" }}
            if vt.Kind != goskema.TokenBool {
                if vt.Kind == goskema.TokenBeginObject || vt.Kind == goskema.TokenBeginArray {
                    depth := 1
                    for depth > 0 {
                        t2, err := src.NextToken()
                        if err != nil { var zero {{$tn}}; return zero, fmt.Errorf("parse error: %w", err) }
                        switch t2.Kind {
                        case goskema.TokenBeginObject, goskema.TokenBeginArray:
                            depth++
                        case goskema.TokenEndObject, goskema.TokenEndArray:
                            depth--
                        }
                    }
                }
                issues = goskema.AppendIssues(issues, goskema.Issue{Code: goskema.CodeInvalidType, Path: "/{{.JSON}}", Message: "expected bool"})
                if goskema.IsFailFast(ctx) { var zero {{$tn}}; return zero, issues }
                continue
            }
            out.{{.Go}} = vt.Bool
            {{- else }}
            // TODO: non-primitive field parsing not implemented yet; drain value
            if err := skipValue(src); err != nil { var zero {{$tn}}; return zero, fmt.Errorf("parse error: %w", err) }
            {{- end }}
        {{- end }}
        {{- else }}
        {{- range .Fields }}
        case "{{.}}":
            // TODO: call field parser and assign to out. Mark presence seen.
            seen["{{.}}"] = true
            if err := skipValue(src); err != nil { var zero {{$.Name}}; return zero, fmt.Errorf("parse error: %w", err) }
        {{- end }}
        {{- end }}
        default:
            // Unknown key handling per UnknownPolicy
            switch unknownPolicy {
            case goskema.UnknownStrict:
                // collect issue (and optionally fail fast)
                issues = goskema.AppendIssues(issues, goskema.Issue{Code: goskema.CodeUnknownKey, Path: "/"+k, Message: "unknown key: "+k})
                if goskema.IsFailFast(ctx) {
                    var zero {{.Name}}
                    return zero, issues
                }
                // still need to drain value to keep stream balanced
                if err := skipValue(src); err != nil { var zero {{.Name}}; return zero, err }
            case goskema.UnknownStrip:
                // drain and drop
                if err := skipValue(src); err != nil { var zero {{.Name}}; return zero, err }
            case goskema.UnknownPassthrough:
                // TODO: build any and assign to unknownTarget; for now, drain
                if err := skipValue(src); err != nil { var zero {{.Name}}; return zero, err }
            default:
                if err := skipValue(src); err != nil { var zero {{.Name}}; return zero, err }
            }
        }
    }
    // end-of-object checks: required and default materialization (skeleton)
    // required list (may be empty until IR wiring is complete)
    required := []string{ {{range .Required}}"{{.}}", {{end}} }
    for _, req := range required {
        if !seen[req] {
            issues = goskema.AppendIssues(issues, goskema.Issue{Code: goskema.CodeRequired, Path: "/"+req, Message: "required field missing: "+req})
            if goskema.IsFailFast(ctx) { var zero {{$tn}}; return zero, issues }
        }
    }
    // defaults
    {{- range .BoundFields }}
    {{- if .HasDefault }}
    if !seen["{{.JSON}}"] {
        // materialize default
        {{- if eq .Kind "string" }}
        out.{{.Go}} = {{.DefaultLit}}
        {{- else if eq .Kind "bool" }}
        out.{{.Go}} = {{.DefaultLit}}
        {{- end }}
    }
    {{- end }}
    {{- end }}
    {{end}}
    if len(issues) > 0 {
        var zero {{.Name}}
        return zero, issues
    }
    return out, nil
}

// Validate{{.Name}}FromReader is a stub for the compiled io.Reader validator.
func Validate{{.Name}}FromReader(ctx context.Context, r io.Reader) ({{.Name}}, error) {
    var zero {{.Name}}
    return zero, fmt.Errorf("compiled Validate{{.Name}}FromReader: not implemented yet")
}
{{end}}
`))

type fileIR struct {
	Package string
	Types   []TypeDef
}

// RenderFileFromIR renders using TypeDefs carrying object field names.
func RenderFileFromIR(pkg string, defs []TypeDef) ([]byte, error) {
	// finalize bound fields for each typedef
	for i := range defs {
		finalizeTypeDef(&defs[i])
	}
	var buf bytes.Buffer
	data := fileIR{Package: pkg, Types: defs}
	if err := fileIRTmpl.Execute(&buf, data); err != nil {
		return nil, fmt.Errorf("render IR template: %w", err)
	}
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return buf.Bytes(), nil
	}
	return formatted, nil
}

// ---- IR mapping helpers ----

// TypeDefFromIR converts an internal IR schema into a TypeDef used by templates.
// Currently supports object nodes; other nodes fall back to empty Fields.
func TypeDefFromIR(name string, node isir.Schema) TypeDef {
	def := TypeDef{Name: name}
	if node == nil {
		return def
	}
	if obj, ok := node.(*isir.Object); ok {
		// fields (stable order)
		if len(obj.Fields) > 0 {
			names := make([]string, 0, len(obj.Fields))
			kinds := make(map[string]string, len(obj.Fields))
			defs := make(map[string]any, len(obj.Fields))
			for _, f := range obj.Fields {
				names = append(names, f.Name)
				switch nf := f.Schema.(type) {
				case *isir.Primitive:
					kinds[f.Name] = nf.Name
				case *isir.Array:
					kinds[f.Name] = "array"
				case *isir.Object:
					kinds[f.Name] = "object"
				default:
					kinds[f.Name] = ""
				}
				if f.Default != nil {
					defs[f.Name] = f.Default
				}
			}
			sort.Strings(names)
			def.Fields = names
			def.Kinds = kinds
			if len(defs) > 0 {
				def.Defaults = defs
			}
		}
		// required
		if len(obj.Required) > 0 {
			req := make([]string, 0, len(obj.Required))
			for k := range obj.Required {
				req = append(req, k)
			}
			sort.Strings(req)
			def.Required = req
		}
		// unknown policy/target
		def.UnknownPolicy = obj.UnknownPolicy
		def.UnknownTarget = obj.UnknownTarget
	}
	return def
}

// RenderFileFromIRNodes renders by accepting a map of type name to internal IR schema.
func RenderFileFromIRNodes(pkg string, nodes map[string]isir.Schema) ([]byte, error) {
	defs := make([]TypeDef, 0, len(nodes))
	for name, n := range nodes {
		defs = append(defs, TypeDefFromIR(name, n))
	}
	// stable order for output determinism
	sort.Slice(defs, func(i, j int) bool { return defs[i].Name < defs[j].Name })
	return RenderFileFromIR(pkg, defs)
}

// RenderFileFromIRNodesWithBindings is like RenderFileFromIRNodes but additionally wires
// JSON->Go field bindings for each type, enabling field assignment generation.
func RenderFileFromIRNodesWithBindings(pkg string, nodes map[string]isir.Schema, bindings map[string]map[string]string) ([]byte, error) {
	defs := make([]TypeDef, 0, len(nodes))
	for name, n := range nodes {
		def := TypeDefFromIR(name, n)
		if bmap, ok := bindings[name]; ok {
			def.Bindings = bmap
		}
		finalizeTypeDef(&def)
		defs = append(defs, def)
	}
	// stable order for output determinism
	sort.Slice(defs, func(i, j int) bool { return defs[i].Name < defs[j].Name })
	return RenderFileFromIR(pkg, defs)
}

// finalizeTypeDef populates BoundFields if Bindings/Kinds are available.
func finalizeTypeDef(def *TypeDef) {
	if len(def.Fields) == 0 {
		return
	}
	// Build bound fields; if a binding is missing, guess by exporting JSON name.
	bfs := make([]BoundField, 0, len(def.Fields))
	for _, jsonName := range def.Fields {
		goField := ""
		if def.Bindings != nil {
			goField = def.Bindings[jsonName]
		}
		if goField == "" {
			goField = exportName(jsonName)
		}
		kind := ""
		if def.Kinds != nil {
			kind = def.Kinds[jsonName]
		}
		bf := BoundField{JSON: jsonName, Go: goField, Kind: kind}
		// default literal for primitives
		if def.Defaults != nil {
			if dv, ok := def.Defaults[jsonName]; ok {
				if lit, ok2 := toGoLiteral(kind, dv); ok2 {
					bf.HasDefault = true
					bf.DefaultLit = lit
				}
			}
		}
		bfs = append(bfs, bf)
	}
	// keep JSON name order
	def.BoundFields = bfs
}

func exportName(s string) string {
	if s == "" {
		return s
	}
	runes := []rune(s)
	runes[0] = []rune(strings.ToUpper(string(runes[0])))[0]
	return string(runes)
}

// toGoLiteral renders a best-effort Go literal for a primitive default value.
func toGoLiteral(kind string, v any) (string, bool) {
	switch kind {
	case "string":
		if s, ok := v.(string); ok {
			return fmt.Sprintf("%q", s), true
		}
	case "bool":
		if b, ok := v.(bool); ok {
			if b {
				return "true", true
			}
			return "false", true
		}
	case "number":
		// represent as string literal for now; mapping to json.Number or float64 is deferred
		if s, ok := v.(string); ok {
			return fmt.Sprintf("%q", s), true
		}
	}
	return "", false
}
