// Code generated by goskema compile; DO NOT EDIT.
// Generated by internal/gen

package user

import (
	"context"
	"fmt"
	goskema "github.com/reoring/goskema"
	"io"
)

// ValidateUser is a stub for the compiled validator.
func ValidateUser(ctx context.Context, data any) (User, error) {
	var zero User
	return zero, fmt.Errorf("compiled validator for User: not implemented yet")
}

// ParseFromUser is a stub for the compiled streaming parser.
func ParseFromUser(ctx context.Context, src goskema.Source) (User, error) {
	// Parse options placeholder. Generators will populate fields as needed.
	var opt goskema.ParseOpt
	// Local issue collection; enforcement is applied only when needed.
	var issues goskema.Issues
	src = goskema.EnforceSourceIfNeeded(src, opt)
	// Wire fail-fast into context so downstream validators can honor it.
	ctx = goskema.WithFailFast(ctx, opt.FailFast)
	// expect begin-object
	tok, err := src.NextToken()
	if err != nil {
		return User{}, fmt.Errorf("parse error: %w", err)
	}
	if tok.Kind != goskema.TokenBeginObject {
		// invalid_type as Issues for uniformity
		var zero User
		iss := goskema.AppendIssues(nil, goskema.Issue{Code: goskema.CodeInvalidType, Path: "/", Message: "expected object"})
		return zero, iss
	}
	// field loop skeleton (known fields listed for future inline branches)

	// known fields: "active", "name"
	// seen map for required check at end
	seen := map[string]bool{"active": false, "name": false}
	// unknown policy (default Strict until IR wiring populates it)
	unknownPolicy := goskema.UnknownPolicy(0)
	// presence collection is only for WithMeta variants; omit here for performance
	// output value
	var out User
	// helper to skip an entire value subtree
	skipValue := func(s goskema.Source) error {
		v, err := s.NextToken()
		if err != nil {
			return err
		}
		switch v.Kind {
		case goskema.TokenBeginObject:
			depth := 1
			for depth > 0 {
				t, err := s.NextToken()
				if err != nil {
					return err
				}
				switch t.Kind {
				case goskema.TokenBeginObject, goskema.TokenBeginArray:
					depth++
				case goskema.TokenEndObject, goskema.TokenEndArray:
					depth--
				}
			}
		case goskema.TokenBeginArray:
			depth := 1
			for depth > 0 {
				t, err := s.NextToken()
				if err != nil {
					return err
				}
				switch t.Kind {
				case goskema.TokenBeginObject, goskema.TokenBeginArray:
					depth++
				case goskema.TokenEndObject, goskema.TokenEndArray:
					depth--
				}
			}
		default:
			// primitives: nothing to do
		}
		return nil
	}
	for {
		t, err := src.NextToken()
		if err != nil {
			var zero User
			return zero, fmt.Errorf("parse error: %w", err)
		}
		if t.Kind == goskema.TokenEndObject {
			break
		}
		if t.Kind != goskema.TokenKey {
			var zero User
			return zero, goskema.Issues{goskema.Issue{Code: goskema.CodeParseError, Path: "/", Message: "unexpected token in object"}}
		}
		k := t.String
		// inline branches per known field name
		switch k {
		case "active":
			seen["active"] = true
			vt, err := src.NextToken()
			if err != nil {
				var zero User
				return zero, fmt.Errorf("parse error: %w", err)
			}
			if vt.Kind != goskema.TokenBool {
				if vt.Kind == goskema.TokenBeginObject || vt.Kind == goskema.TokenBeginArray {
					depth := 1
					for depth > 0 {
						t2, err := src.NextToken()
						if err != nil {
							var zero User
							return zero, fmt.Errorf("parse error: %w", err)
						}
						switch t2.Kind {
						case goskema.TokenBeginObject, goskema.TokenBeginArray:
							depth++
						case goskema.TokenEndObject, goskema.TokenEndArray:
							depth--
						}
					}
				}
				issues = goskema.AppendIssues(issues, goskema.Issue{Code: goskema.CodeInvalidType, Path: "/active", Message: "expected bool"})
				if goskema.IsFailFast(ctx) {
					var zero User
					return zero, issues
				}
				continue
			}
			out.Active = vt.Bool
		case "name":
			seen["name"] = true
			vt, err := src.NextToken()
			if err != nil {
				var zero User
				return zero, fmt.Errorf("parse error: %w", err)
			}
			if vt.Kind != goskema.TokenString {
				if vt.Kind == goskema.TokenBeginObject || vt.Kind == goskema.TokenBeginArray {
					depth := 1
					for depth > 0 {
						t2, err := src.NextToken()
						if err != nil {
							var zero User
							return zero, fmt.Errorf("parse error: %w", err)
						}
						switch t2.Kind {
						case goskema.TokenBeginObject, goskema.TokenBeginArray:
							depth++
						case goskema.TokenEndObject, goskema.TokenEndArray:
							depth--
						}
					}
				}
				issues = goskema.AppendIssues(issues, goskema.Issue{Code: goskema.CodeInvalidType, Path: "/name", Message: "expected string"})
				if goskema.IsFailFast(ctx) {
					var zero User
					return zero, issues
				}
				continue
			}
			out.Name = vt.String
		default:
			// Unknown key handling per UnknownPolicy
			switch unknownPolicy {
			case goskema.UnknownStrict:
				// collect issue (and optionally fail fast)
				issues = goskema.AppendIssues(issues, goskema.Issue{Code: goskema.CodeUnknownKey, Path: "/" + k, Message: "unknown key: " + k})
				if goskema.IsFailFast(ctx) {
					var zero User
					return zero, issues
				}
				// still need to drain value to keep stream balanced
				if err := skipValue(src); err != nil {
					var zero User
					return zero, err
				}
			case goskema.UnknownStrip:
				// drain and drop
				if err := skipValue(src); err != nil {
					var zero User
					return zero, err
				}
			case goskema.UnknownPassthrough:
				// TODO: build any and assign to unknownTarget; for now, drain
				if err := skipValue(src); err != nil {
					var zero User
					return zero, err
				}
			default:
				if err := skipValue(src); err != nil {
					var zero User
					return zero, err
				}
			}
		}
	}
	// end-of-object checks: required and default materialization (skeleton)
	// required list (may be empty until IR wiring is complete)
	required := []string{"name"}
	for _, req := range required {
		if !seen[req] {
			issues = goskema.AppendIssues(issues, goskema.Issue{Code: goskema.CodeRequired, Path: "/" + req, Message: "required field missing: " + req})
			if goskema.IsFailFast(ctx) {
				var zero User
				return zero, issues
			}
		}
	}
	// defaults
	if !seen["active"] {
		// materialize default
		out.Active = true
	}

	if len(issues) > 0 {
		var zero User
		return zero, issues
	}
	return out, nil
}

// ValidateUserFromReader is a stub for the compiled io.Reader validator.
func ValidateUserFromReader(ctx context.Context, r io.Reader) (User, error) {
	var zero User
	return zero, fmt.Errorf("compiled ValidateUserFromReader: not implemented yet")
}
